## AMR シミュレータ: 迂回時の斜め移動（棚横切り）防止 仕様

### 背景
現在の `App.tsx` は矩形ループ（上辺/下辺/左右辺）上を AMR が周回し、中央障害物の発生時に中央系ループから外側ループへ「迂回」する。視覚上まれに、迂回への切替タイミングで AMR が棚領域を横切るような「斜め移動」が発生する。

### 現象
- 迂回開始（または復帰）時、AMR の軌跡が一瞬、棚（白矩形）内を貫く斜め線として描かれることがある。
- 実際の座標更新でも、角・辺上の拘束が弱いフレームで x と y が同時に変化し、自由空間を斜めに短絡する場合がある。

### 原因（問題点）
1. **目標点追従ベクトル更新**: 通常移動が「次の頂点へのベクトル」を正規化して加算する方式のため、数値誤差や直前の処理によって辺から微小に外れた状態で更新されると、x・y が同時に動き斜め成分が混入する。
2. **スナップの不足**: 水平/垂直エッジ上と判定する許容誤差（eps）チェックはあるが、判定後に座標を厳密にエッジへ「投影/スナップ」していないため、以後の更新で斜めドリフトが残りうる。
3. **切替タイミングの非原子的更新**: ループ切替（`transition`）の開始・終了と `idx`/`path` の更新がフレーム境界で原子的に扱われず、描画の接続線や直前座標との関係で「旧エッジ→新エッジ」を一本の斜線で結んでしまうことがある。
4. **オーバーシュート処理不足**: 角到達時に残余距離の繰り越しやセグメント進捗の厳密管理がなく、corner 直前/直後で `idx` 反転や切替が起きると「角を飛び越え」たような更新が発生し、結果として斜め補間が起きる場合がある。
5. **逆走/押し戻しの正規化不足**: 障害物衝突時の「直前位置へ戻す」「`idx` を逆方向へ」などの処理後に、位置をエッジへ再投影し直さないため、次フレームが斜めに始まる可能性がある。
6. **棚との最終チェックが無い**: 線分（旧→新座標）が棚矩形と交差しないことの最終保証が無く、可視的にも論理的にも「棚を横切る線」が残り得る。

### 目的
- 迂回/復帰や逆走の有無に関わらず、AMR の移動を常に「ルートのエッジ上の1次元運動」として扱い、斜め移動を構造的に不可能にする。
- 描画上も、トポロジー切替（ループ/エッジ切替）をまたぐ線分が棚内を横切らないようにする。

### 改善仕様

#### 1) 経路モデルをセグメント駆動に変更
- 各ループを「4エッジ（上/右/下/左）」と「4コーナー」で表すグラフにする。
- エッジは以下の属性を持つ:
  - `orientation`: `horizontal` または `vertical`
  - `fixedCoord`: 水平なら `y = topY|botY`、垂直なら `x = x1|x2`
  - `from`, `to`: コーナー座標（同一 y か同一 x）
  - `length`: `|to - from|`
- Bot は「現在のエッジID」「進行向き（+1/-1）」「エッジ内進捗 `s`（0..length）」で位置を保持する。
  - 位置は常に `orientation` に応じて片方の座標を `fixedCoord` に固定し、もう片方を `from + s * dir` として算出する。
  - 速度更新は `s += v * dt`。`s` が範囲を越えた分は残余距離として次のエッジへ繰り越す（角で原子的に切替）。

#### 2) 切替条件と手順（迂回/復帰）
- ループ切替は「水平エッジ上のみ」許可とする（現行方針を厳格化）。
- 切替トリガーが立った場合の手順:
  1. 現在エッジが水平であることを確認。水平でなければ「角に到達するまで保留」。
  2. 現エッジの相対進捗 `t = s / length` を計算。
  3. 新ループ側の対応水平エッジに写像（`t` を同一に保ったまま `x` のみ変更）。
  4. 切替は原子的に行い、そのフレーム内では y を厳密に `fixedCoord` に、x は新しいエッジ上の値に設定する（x,y 同時更新だが幾何的に水平移動のため棚内へは入らない）。
  5. 切替直後の「次のコーナー方向」は、元の進行向きと一致させる。
- 復帰も同手順（障害物 OFF 中のみ許可）。

#### 3) 逆走/押し戻しの正規化
- 衝突や障害物押し戻しは「現在エッジの法線方向」にのみ行う（水平なら ±y、垂直なら ±x）。
- 押し戻し後は必ず位置を該当エッジへ再投影し、`s` を再計算して一貫性を保つ。
- 逆走は「進行向き `dir` を反転」して表現し、`idx` ベースの突発的な角飛びを避ける。

#### 4) スナップと数値安定性
- 毎フレーム終了時、位置をエッジへ厳密にスナップ（固定軸を厳密に再設定）。
- スナップ閾値は `epsilon = 0.5px` とし、閾値未満のズレは切り捨てる。
- コーナー到達は「`s` の比較」で判定し、残余距離を次エッジへ繰り越す（オーバーシュートでの斜め短絡を防止）。

#### 5) 描画の一貫性（トレイル）
- ループ/エッジ切替が起きたフレームは、トレイルを「分割描画」する：
  - 旧座標→切替点（水平エッジ上）
  - 切替点→新座標
- または切替フレームだけトレイル接続を抑制（`justSwitched` フラグで1フレーム線分をスキップ）。
- これにより、視覚的な棚横切り斜線を防ぐ。

#### 6) フェイルセーフ: 棚交差ガード
- 毎フレーム、`oldPos→newPos` の線分が棚矩形と交差しないことを検査（高速な AABB 交差）。
- 交差を検出した場合:
  - 位置を `oldPos` に戻す
  - 進捗/切替をロールバック
  - 状況に応じて「角到達待ち」や「水平エッジ待ち」にフォールバック

### 非機能要件 / テスト
- 自己診断（`runSelfTests` 拡張）:
  - 各ステップで「位置が必ずどれかのエッジ上（固定軸が厳密）」であることを検証。
  - 切替時に `t` が保存されること。
  - 10000 ステップ連続更新で最大偏差 < 0.25px を保証。
- プロパティテスト:
  - 任意の時刻/障害 ON/OFF トグル列に対し、棚矩形への交差が常に false。
- パフォーマンス:
  - 3 体規模で 60fps 維持（現行同等）。

### 互換性・影響範囲
- 速度・見た目の挙動は概ね現行同等（角部での動きが安定化）。
- 既存の `transition` 構造は流用可能だが、内部表現をエッジ進捗ベースへ置換する。
- 外部 API/入力（キー操作、ポーリング仕様）は無変更。

### 実装メモ（インターフェース案）
- 追加フィールド（Bot）:
  - `edgeId: number`
  - `edgeDir: 1 | -1`
  - `edgeS: number`  // 0..length
  - `justSwitched?: boolean`
- ヘルパ:
  - `getEdge(loop, edgeId) -> {orientation, fixedCoord, from, to, length}`
  - `advanceAlongEdge(bot, ds) -> { carryToNextEdgeIfNeeded }`
  - `projectToEdge(bot) -> void`  // スナップ
  - `mapProgressToLoop(srcLoop, dstLoop, edgeId, t) -> {dstEdgeId, s}`
- 切替フロー:
  1. 水平エッジ上で `t = edgeS / length` を取得
  2. `dstEdgeId = 対応する水平エッジ`
  3. `edgeS = t * dst.length`、`edgeDir` は維持
  4. `justSwitched = true`

---
この仕様により、座標更新・可視化の両面で斜め短絡が構造的に排除され、「棚を横切るような斜め移動」が発生しないことを保証する。


